; NAME: Денисов Дмитрий Сергеевич, КРБО-01-17
; SUBJ: Микропроцессорная техника в мехатронике и робототехнике
; TITLE: №25. Контроллер трёхцветной линейки светодиодов (WS2812b)
; DATE: 18.12.2019

; "Led_rgb_Array"


.DEVICE ATmega8; указываем микроконтроллер
.include "D:\AVR-master\asm\include\m8def.inc"; добавляем заголовочный файл

.def temp = r16; задём регистр для хранения временных данных
.def bits = r17; регистр для хранения количества битов цвета

.def led_count = r18; регистр для хранения количества светодиодов
.def mode = r19; регистр для хранения номера режима

.def r = r20; регистр для хранения значения красного цвета
.def g = r21; зелёного цвета
.def b = r22; синего цвета

.dseg; команда дря работы с памятью данных,
; где будут храниться массивы цветов
Red: .byte 8; указываем количество байт=количеству светодиодов в ленте!
Green: .byte 8
Blue: .byte 8

.cseg; команда для работы с памятью программ

.org 0; вектор сброса
rjmp Reset; переход на функцию сброса

.org 0x001; вектор внешнего прерывания INT0
rjmp EXT_INT0; переход на функцию обработки прерывания


; Функция сброса (первоначальной настройки)
Reset:
ldi temp, 0xff; задаём все выводы порта B на выход
out DDRB, temp
ldi temp, 0xff; задаём все выводы порта C на выход
out DDRC, temp
ldi temp, 0x00; подаём на все выводы C 0
out PORTC, temp
ldi temp, 0b11111011; задаём все выводы порта D на выход, а PD2 на вход
out DDRD, temp
ldi temp, 0b00000100; устанавливаем режим PullUp для вывода PD2
out PORTD, temp
; настраиваем внешнее прерывание INT0
ldi temp, (1<<ISC01)+(0<<ISC00); задаём в регистре MCUCR тип прерывание -
out MCUCR, temp; - прерывание по заднему фронту (переход с 1 на 0)
ldi temp, (1<<INT0); разрешаем прерывание INT0
out GICR, temp
; выполняем первоначальную настройку некоторых регистров
ldi mode, 1; задаём первый режим работы
ldi r,0; задаём изначально чёрный цвет пикселей
ldi g,0
ldi b,0
rjmp Main; переходим в основную функцию программы


; основная функция программы
Main:
; с помощью данных команд мы можем использовать для выхода из прерывания
; не reti, а rjmp Main (что необходимо для правильной работы алгоритма)
ldi temp,low(RamEnd); инициализируем стек
out SPL, temp; делаем это в функции Main для того, 
ldi temp,high(RamEnd); чтобы, переходя из прерывания в Main, 
out SPH, temp; сбрасывать значения в стеке
sei; разрешаем глобальные прерывания
Cycle:
rcall CodeRes; вызываем функцию сброса состояния светодиодов
ldi XL, low(Red); задаём начальные значения индексным регистрам
ldi XH, high(Red); для работы с нашими массивами
ldi YL, low(Green)
ldi YH, high(Green)
ldi ZL, low(Blue)
ldi ZH, high(Blue)
ldi led_count, 8; задаём количество светодиодов в ленте
; цикл "зажигания" каждого светодиода
LedCyc: 
ld r, X+; косвенно считываем данные из массивов в регистры
ld g, Y+; с постинкрементом
ld b, Z+
rcall RGB; вызов функции обработки цветов
dec led_count; уменьшаем кол-во незажжённых светодиодов
brne LedCyc; если кол-во светодиодов не равно 0, то снова выполняем цикл
rjmp Cycle; зацикливаем основную функцию


; функция сброса состояния светодиодов
; для сброса состояния нам нужна задержка больше 50 мкс
CodeRes:
ldi temp, 2; записываем в регистр 2
ldi bits, 9; записываем в регистр 9
; далее вычитаем из них 1 до тех пор, пока они не равны 0
L1:
dec bits
brne L1
dec temp
brne L1
ret; возвращаемся из функции


; функция обработки цветов
RGB:
push temp
push r; так как дальнейший алгоритм будет оставлять в регистрах 0, то
push g; сохраняем регистры rgb в стэк
push b
ldi bits, 24; количество битов, задающих цвет светодиода
; цикл обработки цветов
RgbCyc:
ldi temp, 0b00000000; подаём 0 на PB0
out portb, temp
lsl b; выполняем сдвиг влево, занося 7 бит в C
rol r; выполняем логический сдвиг с битом C
rol g; выполняем логический сдвиг с битом C
brcc Code0; если бит С=0, то переходим на метку code0
ldi temp, 0b00000001; если 1, то подаём 1 на PB0
out portb, temp
nop; пустая команда для реализации необходимого импульса
nop; для подачи 1 на светодиод подаём лог. 1 на ~0,68мкс
nop; а 0 будет подаваться >=0.38мкс
rjmp CountBits; переходим на метку подсчёта цикла
; метка подачи 0 на светодиод
Code0:
ldi temp, 0b00000001; для этого подаём 1 на 0.2мкс
out portb, temp
nop
ldi temp, 0b00000000; и подаём 0 на >=0.8мкс
out portb, temp
; подсчёт итераций цикла, необходимых для задачи цвета пикселя
CountBits:
dec bits; уменьшаем кол-во битов
brne RgbCyc; переходим, если кол-во битов не равно 0 
ldi temp, 0b00000000; подаём 0, если это был последний бит
out portb, temp
pop b; забираем значения регистров rgb из стека
pop g
pop r
pop temp
ret; выход из функции


; функция обработки внешнего прерывания INT0
EXT_INT0:
rcall CodeRes; вызываем функцию сброса состояния светодиодов
ldi XL, low(Red); задаём начальные значения индексным регистрам
ldi XH, high(Red); для работы с нашими массивами
ldi YL, low(Green)
ldi YH, high(Green)
ldi ZL, low(Blue)
ldi ZH, high(Blue)
; метка первого режима
Mode1:
cpi mode, 1; проверяем, 1й ли режим записан в регистр
brne Mode2; если нет, то переходим на метку второго режима
ldi r, 255; задаём красный цвет
ldi g, 0
ldi b, 0
ldi mode, 2; устанавливаем теперь значение следующего режима.
rjmp St_arr; переходим в подпрограмму записи одинаковых значений в массивы rgb
; метка второго режима (работает конструкция аналогично)
Mode2:
cpi mode, 2
brne Mode3
ldi r, 255; задаём оранжевый цвет
ldi g, 127
ldi b, 0
ldi mode, 3
rjmp St_arr 
; метка третьего режима
Mode3:
cpi mode, 3
brne Mode4
ldi r, 255; задаём жёлтый цвет
ldi g, 255
ldi b, 0
ldi mode, 4
rjmp St_arr
; метка 4-го режима
Mode4:
cpi mode, 4
brne Mode5
ldi r, 0; задаём зелёный цвет
ldi g, 255
ldi b, 0
ldi mode, 5
rjmp St_arr
; метка 5-го режима
Mode5:
cpi mode, 5
brne Mode6
ldi r, 0; задаём голубой цвет
ldi g, 0
ldi b, 255
ldi mode, 6
rjmp St_arr
; метка 6-го режима
Mode6:
cpi mode, 6
brne Mode7
ldi r, 75; задаём синий цвет
ldi g, 0
ldi b, 255
ldi mode, 7
rjmp St_arr
; метка 7-го режима
Mode7:
cpi mode, 7
brne Mode8
ldi r, 143; задаём фиолетовый цвет
ldi g, 0
ldi b, 255
ldi mode, 8
rjmp St_arr
; метка 8-го режима
Mode8:
cpi mode, 8
brne Mode9
ldi r, 255; задаём белый цвет
ldi g, 255
ldi b, 255
ldi mode, 9
rjmp St_arr
; 9-й режим - 3 сд красные, 3 сд зелёные, 2 сд синие
Mode9:
ldi r, 255; задаём красный цвет
ldi g, 0
ldi b, 0
ldi temp, 3; сохраняем в первые 3 элемента массивов
Cyc1:
st x+,r; используем косвенную запись значения регистров
st y+,g; в массив данных с постинкрементом
st z+,b
dec temp
brne Cyc1

ldi r, 0; задаём зелёный цвет
ldi g, 255
ldi b, 0
ldi temp, 3; сохраняем во вторые 3 элемента массивов
Cyc2:
st x+,r
st y+,g
st z+,b
dec temp
brne Cyc2

ldi r, 0; задаём синий цвет
ldi g, 0
ldi b, 255
ldi temp, 2; сохраняем в последние 2 элемента массивов
Cyc3:
st x+,r
st y+,g
st z+,b
dec temp
brne Cyc3
ldi mode, 1; задаём следующий режим - первый
rjmp Main; переходим в главную функцию
; здесь заносятся значения первых 8-ми режимов в массивы rgb
St_arr:
ldi temp, 8
Cyc:
st x+,r
st y+,g
st z+,b
dec temp
brne Cyc
rjmp Main
